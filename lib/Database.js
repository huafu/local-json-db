// Generated by CoffeeScript 1.8.0
var Class, CoreObject, Database, MergedRecordStore, Model, fs, mkdirp, sysPath, utils,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

fs = require('fs');

sysPath = require('path');

mkdirp = require('mkdirp');

utils = require('./utils');

CoreObject = require('./CoreObject');

MergedRecordStore = require('./MergedRecordStore');

Model = require('./Model');

Class = null;

Database = (function(_super) {
  __extends(Database, _super);

  Database.prototype._basePath = null;

  Database.prototype._config = null;

  Database.prototype._layers = null;

  Database.prototype._models = null;

  function Database(basePath, config) {
    if (basePath == null) {
      basePath = './json.db';
    }
    if (config == null) {
      config = {};
    }
    this._basePath = sysPath.resolve(basePath);
    this._config = utils.defaults({}, config);
    this._layers = [this._basePath];
    this._models = null;
    this.lockProperties('_basePath', '_config', '_layers');
  }

  Database.prototype.addOverlay = function(path) {
    this.assertNotLoaded('cannot add overlay');
    if (utils.isArray(path)) {
      path = sysPath.join.apply(sysPath, path);
    }
    path = sysPath.resolve(this._basePath, path);
    this.assert(__indexOf.call(this._layers, path) < 0, "you cannot add twice the same path for 2 different overlays");
    this._layers.push(path);
    return this;
  };

  Database.prototype.createRecord = function(modelName, record) {
    return this.modelFactory(modelName).create(record);
  };

  Database.prototype.updateRecord = function(modelName, id, record) {
    var mdl;
    mdl = this.modelFactory(modelName);
    return mdl.update.apply(mdl, [].slice.call(arguments, 1));
  };

  Database.prototype.deleteRecord = function(modelName, id) {
    return this.modelFactory(modelName)["delete"](id);
  };

  Database.prototype.find = function(modelName, id) {
    return this.modelFactory(modelName).find(id);
  };

  Database.prototype.findMany = function() {
    var ids, modelName, _ref;
    modelName = arguments[0], ids = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = this.modelFactory(modelName)).findMany.apply(_ref, ids);
  };

  Database.prototype.findQuery = function(modelName, filter, thisArg) {
    return this.modelFactory(modelName).findQuery(filter, thisArg);
  };

  Database.prototype.findAll = function(modelName) {
    return this.modelFactory(modelName).findAll();
  };

  Database.prototype.count = function(modelName) {
    return this.modelFactory(modelName).count();
  };

  Database.prototype.save = function() {
    var model, models, name, _ref;
    if (this.isLoaded()) {
      models = [];
      _ref = this._models;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        model = _ref[name];
        this._saveModelStore(name, model);
        this.emit('model.store.saved', model);
        models.push(model);
      }
      this.emit('db.saved', model);
    }
    return this;
  };

  Database.prototype.isLoaded = function() {
    return Boolean(this._models);
  };

  Database.prototype.load = function(force) {
    if (force || !this.isLoaded()) {
      this.unload();
      this._models = {};
    }
    return this;
  };

  Database.prototype.unload = function() {
    var model, name, _ref;
    if (this.isLoaded()) {
      _ref = this._models;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        model = _ref[name];
        model.destroy();
      }
      this._models = null;
    }
    return this;
  };

  Database.prototype.destroy = function() {
    this.unload();
    return Database.__super__.destroy.apply(this, arguments);
  };

  Database.prototype.modelFactory = function(modelName) {
    var model, name;
    this.load();
    name = this._modelName(modelName);
    if (!(model = this._models[name])) {
      this._models[name] = model = new Model(this, name, this._createModelStore(name));
      this.emit('model.store.loaded', model);
    }
    return model;
  };

  Database.prototype.modelNameToFileName = function(modelName) {
    Model.assertValidModelName(modelName);
    return "" + (utils.kebabCase(utils.pluralize(modelName))) + ".json";
  };

  Database.prototype.assertNotLoaded = function(msg) {
    return this.assert(!this.isLoaded(), "the database is already loaded" + (msg ? ", " + msg : ''));
  };

  Database.prototype._modelName = function(name) {
    return Model._modelName(name);
  };

  Database.prototype._createModelStore = function(modelName) {
    var data, file, main, path, s, store, stores, _i, _j, _len, _len1, _ref;
    file = this.modelNameToFileName(this._modelName(modelName));
    stores = [];
    _ref = this._layers.slice().reverse();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      path = _ref[_i];
      path = sysPath.join(path, file);
      if (fs.existsSync(path)) {
        data = fs.readFileSync(path, {
          encoding: 'utf8'
        });
        data = JSON.parse(data);
        stores.push(data);
      } else {
        stores.push({
          config: {},
          records: []
        });
      }
    }
    main = stores.shift();
    store = new MergedRecordStore(main.records, utils.defaults({}, this._config, main.config));
    for (_j = 0, _len1 = stores.length; _j < _len1; _j++) {
      s = stores[_j];
      store.addLayer(s.records, utils.defaults({}, main.config, s.config));
    }
    return store;
  };

  Database.prototype._saveModelStore = function(name, model) {
    var file, path, store, top;
    file = this.modelNameToFileName(this._modelName(name));
    top = this._layers[this._layers.length - 1];
    path = sysPath.join(top, file);
    store = model._store;
    if (store.countRecords(true) === 0) {
      if (fs.existsSync(path)) {
        fs.unlinkSync(path);
      }
    } else {
      mkdirp.sync(top);
      fs.writeFileSync(path, JSON.stringify(store["export"]()));
    }
    return path;
  };

  return Database;

})(CoreObject);

module.exports = Class = Database;
