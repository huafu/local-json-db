// Generated by CoffeeScript 1.8.0
var Class, CoreObject, DictionaryEx, RecordStore, utils,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

utils = require('./utils');

CoreObject = require('./CoreObject');

DictionaryEx = require('./DictionaryEx');

Class = null;

RecordStore = (function(_super) {
  __extends(RecordStore, _super);

  RecordStore.prototype._records = null;

  RecordStore.prototype._config = null;

  RecordStore.prototype._lastId = null;

  RecordStore.prototype._eventsNamespace = null;

  RecordStore.prototype._eventsEmitter = null;

  RecordStore.prototype._readOnly = null;

  function RecordStore(records, config) {
    var readOnly;
    if (records == null) {
      records = [];
    }
    if (config == null) {
      config = {};
    }
    this._records = new DictionaryEx({}, {
      stringifyKeys: true
    });
    this._config = utils.defaults({}, config, {
      createdAtKey: 'createdAt',
      updatedAtKey: 'updatedAt',
      deletedAtKey: 'deletedAt',
      eventsNamespace: 'record',
      eventsEmitter: this,
      readOnly: false
    });
    this._readOnly = false;
    readOnly = Boolean(this._config.readOnly);
    delete this._config.readOnly;
    this._eventsNamespace = this._config.eventsNamespace;
    delete this._config.eventsNamespace;
    this._eventsEmitter = this._config.eventsEmitter;
    delete this._config.eventsEmitter;
    this._lastId = 0;
    this.importRecords(records);
    this._readOnly = readOnly;
    this.lockProperties('_records', '_config', '_eventsNamespace', '_eventsEmitter', '_readOnly');
  }

  RecordStore.prototype.readRecord = function(id) {
    this.assertValidId(id);
    return this._read(id);
  };

  RecordStore.prototype.readAllRecords = function() {
    var id, _i, _len, _ref, _results;
    _ref = this.ids();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      _results.push(this._read(id));
    }
    return _results;
  };

  RecordStore.prototype.createRecord = function(record) {
    var id, int, m, str;
    if (record == null) {
      record = {};
    }
    this.assertWritable();
    this.assertValidRecord(record);
    m = this._importRecord(record);
    this.assert(m.record, "trying to create a record flagged as deleted");
    if ((id = m.id) != null) {
      this.assertIdExists(id, false);
      if (/^[0-9]+$/.test(str = "" + id) && (int = parseInt(str, 10)) > this._lastId) {
        this._lastId = int;
      }
    } else {
      m.id = m.record.id = ++this._lastId;
    }
    return this._create(m);
  };

  RecordStore.prototype.updateRecord = function(id, record) {
    var m;
    this.assertWritable();
    if (arguments.length === 1) {
      record = id;
    } else {
      this.assert((record.id == null) || ("" + id) === ("" + record.id), "the id given `" + id + "` does not match the id in the given record `" + record.id + "`");
      record.id = id;
    }
    this.assertValidRecord(record);
    m = this._importRecord(record);
    this.assert(m.record, "trying to update a record flagged as deleted");
    this.assertIdExists(m.id);
    return this._update(m);
  };

  RecordStore.prototype.deleteRecord = function(id, deletedAt) {
    if (deletedAt == null) {
      deletedAt = null;
    }
    this.assertWritable();
    this.assertIdExists(id);
    return this._delete(id, deletedAt);
  };

  RecordStore.prototype.countRecords = function() {
    return this._records.count();
  };

  RecordStore.prototype.reset = function() {
    this.assertWritable();
    this._records.clear();
    return this;
  };

  RecordStore.prototype.ids = function(includeDeleted) {
    var res;
    if (includeDeleted == null) {
      includeDeleted = false;
    }
    res = this._records.keys();
    if (includeDeleted) {
      res = res.concat(this._records.deletedKeys());
    }
    return res.sort();
  };

  RecordStore.prototype.deletedIds = function() {
    return this._records.deletedKeys().sort();
  };

  RecordStore.prototype.idExists = function(id, includeDeleted) {
    var exists;
    if (includeDeleted == null) {
      includeDeleted = false;
    }
    this.assertValidId(id);
    exists = this._records.exists(id);
    if (!exists && includeDeleted && this._records.deletedExists(id)) {
      exists = {
        isDeleted: true
      };
    }
    return exists;
  };

  RecordStore.prototype.importRecords = function(records) {
    var e, int, m, record, sid, _i, _len, _ref;
    this.assertWritable();
    for (_i = 0, _len = records.length; _i < _len; _i++) {
      record = records[_i];
      m = this._importRecord(record);
      this.assertIdExists(m.id, false);
      if (/^[0-9]+$/.test(sid = "" + m.id) && (int = parseInt(sid, 10)) > this._lastId) {
        this._lastId = int;
      }
      if (m.record) {
        e = this._records.set(m.id, m.record);
        if (m.metadata.createdAt) {
          e.metadata.createdAt = m.metadata.createdAt;
        }
        if (m.metadata.updatedAt) {
          e.metadata.updatedAt = m.metadata.updatedAt;
        }
      } else {
        this.assert(!this._records.deletedExists(m.id), "record with id " + m.id + " already flagged as deleted");
        this._records.deleted(m.id, (_ref = m.metadata.deletedAt) != null ? _ref : null);
      }
    }
    return this;
  };

  RecordStore.prototype.exportRecords = function() {
    var id, _i, _len, _ref, _results;
    _ref = this.ids(this._config.deletedAtKey);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      _results.push(this._read(id, true));
    }
    return _results;
  };

  RecordStore.prototype.exportConfig = function() {
    var k, res, _i, _len, _ref;
    res = {};
    _ref = ['createdAtKey', 'updatedAtKey', 'deletedAtKey', 'readOnly'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      if (this._config[k] != null) {
        res[k] = this._config[k];
      }
    }
    return res;
  };

  RecordStore.prototype["export"] = function() {
    return {
      config: this.exportConfig(),
      records: this.exportRecords()
    };
  };

  RecordStore.prototype.assertValidRecord = function(record, mustHaveId) {
    if (mustHaveId == null) {
      mustHaveId = false;
    }
    this.assert(record && utils.isObject(record), "not a valid record: " + record);
    if (mustHaveId) {
      this.assertValidId(record.id);
    }
    return this;
  };

  RecordStore.prototype.assertValidId = function(id) {
    return this.assert(id != null, "`" + id + "` is not a valid id");
  };

  RecordStore.prototype.assertIdExists = function(id, exists) {
    var test;
    if (exists == null) {
      exists = true;
    }
    test = this.idExists(id);
    if (exists) {
      this.assert(test, "no record with id `" + id + "`");
    } else {
      this.assert(!test, "a record with id `" + id + "` already exists");
    }
    return this;
  };

  RecordStore.prototype.assertWritable = function() {
    return this.assert(!this._readOnly, "the " + (this.className()) + " is read-only");
  };

  RecordStore.prototype.lastAutoId = function() {
    return this._lastId;
  };

  RecordStore.prototype._copyRecord = function(obj) {
    var res;
    res = utils.copy(obj);
    if ((res != null ? res.id : void 0) != null) {
      utils.lock(res, 'id');
    }
    return res;
  };

  RecordStore.prototype._exportRecord = function(record, metadata, keys) {
    var k, rec;
    if (keys == null) {
      keys = this._config;
    }
    if (record != null) {
      rec = this._copyRecord(record);
      if (metadata.deletedAt) {
        if ((k = keys.deletedAtKey)) {
          rec[k] = metadata.deletedAt;
        }
        if ((k = keys.createdAtKey)) {
          delete rec[k];
        }
        if ((k = keys.updatedAtKey)) {
          delete rec[k];
        }
      } else {
        if ((k = keys.createdAtKey)) {
          rec[k] = metadata.createdAt;
        }
        if ((k = keys.updatedAtKey)) {
          rec[k] = metadata.updatedAt;
        }
        if ((k = keys.deletedAtKey)) {
          delete rec[k];
        }
      }
      return rec;
    } else {
      return void 0;
    }
  };

  RecordStore.prototype._importRecord = function(record, keys) {
    var k, m;
    if (keys == null) {
      keys = this._config;
    }
    m = {
      id: null,
      record: this._copyRecord(record),
      metadata: {}
    };
    if ((record != null ? record.id : void 0) != null) {
      m.id = record.id;
    }
    if ((k = keys.deletedAtKey) && record[k]) {
      m.record = null;
      m.metadata.deletedAt = record[k];
    } else {
      if ((k = keys.createdAtKey) && record[k]) {
        m.metadata.createdAt = this._parseDate(record[k]);
        delete m.record[k];
      }
      if ((k = keys.updatedAtKey) && record[k]) {
        m.metadata.updatedAt = this._parseDate(record[k]);
        delete m.record[k];
      }
    }
    return m;
  };

  RecordStore.prototype._update = function(meta) {
    var e, key, rec, value, _ref;
    rec = (e = this._records.entryForKey(meta.id)).value;
    _ref = meta.record;
    for (key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      value = _ref[key];
      if (key !== 'id') {
        if (value === void 0) {
          delete rec[key];
        } else {
          rec[key] = value;
        }
      }
    }
    e = this._records.set(meta.id, rec);
    if (meta.metadata.createdAt) {
      e.metadata.createdAt = meta.metadata.createdAt;
    }
    if (meta.metadata.updatedAt) {
      e.metadata.updatedAt = meta.metadata.updatedAt;
    }
    rec = this._exportRecord(rec, e.metadata);
    this._trigger("" + this._eventsNamespace + ".updated", rec);
    return rec;
  };

  RecordStore.prototype._create = function(meta) {
    var e, record;
    e = this._records.set(meta.id, meta.record);
    if (meta.metadata.createdAt) {
      e.metadata.createdAt = meta.metadata.createdAt;
    }
    if (meta.metadata.updatedAt) {
      e.metadata.updatedAt = meta.metadata.updatedAt;
    }
    record = this._exportRecord(meta.record, e.metadata);
    this._trigger("" + this._eventsNamespace + ".created", record);
    return record;
  };

  RecordStore.prototype._delete = function(id, deletedAt) {
    var e, rec;
    if (deletedAt == null) {
      deletedAt = null;
    }
    rec = this._records.get(id);
    e = this._records.unset(id);
    if (deletedAt) {
      e.metadata.deletedAt = deletedAt;
    }
    rec = this._exportRecord(rec, e.metadata);
    this._trigger("" + this._eventsNamespace + ".deleted", rec);
    return rec;
  };

  RecordStore.prototype._read = function(id, keepDeleted) {
    var e, rec;
    if (keepDeleted == null) {
      keepDeleted = false;
    }
    e = this._records.entryForKey(id);
    if (keepDeleted && !e.value) {
      rec = {
        id: id
      };
    } else {
      rec = e.value;
    }
    return this._exportRecord(rec, e.metadata);
  };

  RecordStore.prototype._trigger = function() {
    var args, event, _ref;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = this._eventsEmitter) != null ? _ref.emit.apply(_ref, [event].concat(__slice.call(args))) : void 0;
  };

  RecordStore.prototype._parseDate = DictionaryEx.prototype._parseDate;

  RecordStore["import"] = function(data) {
    this.assert(utils.isObject(data) && utils.isObject(data.config) && utils.isArray(data.records), 'given data is not valid data to be imported as a RecordStore');
    return new this(data.records, data.config);
  };

  return RecordStore;

})(CoreObject);

module.exports = Class = RecordStore;
